{"ast":null,"code":"const express = require(\"express\");\nconst router = express.Router();\nconst pool = require(\"../db\");\nrequire(\"dotenv\").config();\nconst fetch = require(\"node-fetch\");\nconst LINGVANEX_URL = process.env.LINGVANEX_URL;\nconst API_KEY = process.env.LINGVANEX_API_KEY;\nasync function translateTexts(texts, target) {\n  const response = await fetch(LINGVANEX_URL, {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${API_KEY}`,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      from: \"en\",\n      to: target,\n      data: texts.join(\"\\n\")\n    })\n  });\n  const data = await response.json();\n  if (!data.result) return texts;\n  return data.result.split(\"\\n\");\n}\n\n// ✅ Main endpoint\nrouter.get(\"/\", async (req, res) => {\n  try {\n    const lang = req.query.lang || \"en\";\n    const bbox = req.query.bbox ? req.query.bbox.split(\",\").map(Number) : null;\n    let query = `\n      SELECT id, name, category,\n             ST_AsGeoJSON(geom)::json AS geometry\n      FROM places\n    `;\n    if (bbox && bbox.length === 4) {\n      // spatial filter for visible bounds\n      query += `\n        WHERE ST_Intersects(\n          geom,\n          ST_MakeEnvelope(${bbox[0]}, ${bbox[1]}, ${bbox[2]}, ${bbox[3]}, 4326)\n        )\n      `;\n    }\n    const {\n      rows\n    } = await pool.query(query);\n    let features = rows.map(r => ({\n      type: \"Feature\",\n      geometry: r.geometry,\n      properties: {\n        id: r.id,\n        name: r.name,\n        category: r.category\n      }\n    }));\n\n    // If Kannada translation is requested\n    if (lang === \"kn\") {\n      const texts = rows.map(r => r.name);\n      const translated = await translateTexts(texts, \"kn\");\n      features = features.map((f, i) => ({\n        ...f,\n        properties: {\n          ...f.properties,\n          name_kn: translated[i]\n        }\n      }));\n    }\n    res.json({\n      type: \"FeatureCollection\",\n      features\n    });\n  } catch (err) {\n    console.error(\"PostGIS fetch error:\", err);\n    res.status(500).json({\n      error: \"PostGIS fetch failed\"\n    });\n  }\n});\nmodule.exports = router;","map":{"version":3,"names":["express","require","router","Router","pool","config","fetch","LINGVANEX_URL","process","env","API_KEY","LINGVANEX_API_KEY","translateTexts","texts","target","response","method","headers","Authorization","body","JSON","stringify","from","to","data","join","json","result","split","get","req","res","lang","query","bbox","map","Number","length","rows","features","r","type","geometry","properties","id","name","category","translated","f","i","name_kn","err","console","error","status","module","exports"],"sources":["/app/src/App.js"],"sourcesContent":["const express = require(\"express\");\nconst router = express.Router();\nconst pool = require(\"../db\");\nrequire(\"dotenv\").config();\nconst fetch = require(\"node-fetch\");\n\nconst LINGVANEX_URL = process.env.LINGVANEX_URL;\nconst API_KEY = process.env.LINGVANEX_API_KEY;\n\nasync function translateTexts(texts, target) {\n  const response = await fetch(LINGVANEX_URL, {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${API_KEY}`,\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({ from: \"en\", to: target, data: texts.join(\"\\n\") }),\n  });\n  const data = await response.json();\n  if (!data.result) return texts;\n  return data.result.split(\"\\n\");\n}\n\n// ✅ Main endpoint\nrouter.get(\"/\", async (req, res) => {\n  try {\n    const lang = req.query.lang || \"en\";\n    const bbox = req.query.bbox ? req.query.bbox.split(\",\").map(Number) : null;\n\n    let query = `\n      SELECT id, name, category,\n             ST_AsGeoJSON(geom)::json AS geometry\n      FROM places\n    `;\n\n    if (bbox && bbox.length === 4) {\n      // spatial filter for visible bounds\n      query += `\n        WHERE ST_Intersects(\n          geom,\n          ST_MakeEnvelope(${bbox[0]}, ${bbox[1]}, ${bbox[2]}, ${bbox[3]}, 4326)\n        )\n      `;\n    }\n\n    const { rows } = await pool.query(query);\n    let features = rows.map((r) => ({\n      type: \"Feature\",\n      geometry: r.geometry,\n      properties: { id: r.id, name: r.name, category: r.category },\n    }));\n\n    // If Kannada translation is requested\n    if (lang === \"kn\") {\n      const texts = rows.map((r) => r.name);\n      const translated = await translateTexts(texts, \"kn\");\n\n      features = features.map((f, i) => ({\n        ...f,\n        properties: { ...f.properties, name_kn: translated[i] },\n      }));\n    }\n\n    res.json({ type: \"FeatureCollection\", features });\n  } catch (err) {\n    console.error(\"PostGIS fetch error:\", err);\n    res.status(500).json({ error: \"PostGIS fetch failed\" });\n  }\n});\n\nmodule.exports = router;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}